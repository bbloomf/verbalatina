<html>
<head>
<meta charset="UTF-8">
<title>Verb Tester</title>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
</head>
<body>
<span id='verb-count'>0</span> verbs in list (<span id='queue'>0</span> in queue)
<input id='regex' style='width: 100%'>
<span id='valid'><span id='matches'>0</span> matches</span>
<span id='invalid' style='color: darkred;'>Invalid regular expression: <span></span></span>
<table class='table'>
<thead>
<tr><th>Verb</th><th>Class</th><th>Infinitive</th><th>Entire Entry</th></tr>
</thead>
<tbody></tbody>
</table>
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>
<script>
Array.prototype.addToIndex = function(index, object) {
  switch(typeof(this[index])) {
    case 'undefined':
      this[index] = [object];
      break;
    case 'object':
      if($.isArray(this[index])) {
        this[index].push(object);
        break;
      }
    default:
      this[index] = [this[index],object];
      break;
  }
};
function getVerbParts(orth, verbMatch) {
  if(!verbMatch[1]) {
    console.info('unknown verb:', orth);
    return {};
  }
  var root = orth;
  var parts = {};
  var verbEnding = orth.match(/(?:([eĕ])|([iĭ]))?([oōŏ])(r?)$|(f[eĕ]r[ot]|[aeiāăäĕēëīĭï]t|tur|sum)$/)
  if(!verbEnding) verbEnding = [];
  if(verbEnding[1]) verbEnding.eo = true; else verbEnding[1] = '';
  if(verbEnding[2]) verbEnding.io = true; else verbEnding[2] = '';
  if(verbEnding[3]) verbEnding.firstPerson = true; else verbEnding[3] = '';
  if(verbEnding[4]) verbEnding.deponent = true; else verbEnding[4] = '';
  verbMatch[1].forEach(function(conj) {
    switch(conj) {
      case 1:
        if(verbEnding.firstPerson) root = orth.slice(0,-(verbEnding[3].length+verbEnding[4].length));
        parts.infinitive = root + 'āre';
        parts.supine = root + 'ātum';
        parts.perfect = root + 'āvisse'
        break;
      case 2:
        if(!verbEnding.eo) {
          var tempMatch = orth.match(/[eēĕë]t(ur)?$/);
          if(tempMatch) {
            root = orth.slice(0,-(tempMatch[1]||'').length);
          } else {
            console.warn(orth + ' should end with -eo because it is marked as second conjugation (ēre)');
          }
        } else {
          root = orth.slice(0,-(verbEnding[1].length+verbEnding[3].length+verbEnding[4].length));
        }
        parts.infinitive = root + 'ēre';
        break;
      case 3:
        root = orth.slice(0,-(verbEnding[2].length+verbEnding[3].length+verbEnding[4].length));
        parts.infinitive = root + 'ĕre';
        if(verbEnding.io) parts.infinitive += ' (io)';
        break;
      case 4:
        if(!verbEnding.io && !verbEnding.eo) console.warn(orth + ' should end with -eo or -io because it is marked as fourth conjugation (īre)');
        root = orth.slice(0,-(verbEnding[1].length+verbEnding[2].length+verbEnding[3].length+verbEnding[4].length));
        parts.infinitive = root + 'īre';
        if(verbEnding.eo) conj = 'eo';
        break;
      case 'perfect':
        if(orth.match(/[iīĭï]$/)) {
          root = orth.slice(0,-1);
          parts.infinitive = parts.perfect = root + 'isse';
        } else console.warn(orth, ' does not end with -i but it is marked as a perfect stem verb');
        break;
      case 'esse':
        if(verbEnding[5] == 'sum') {
          root = orth.slice(0,-3);
          parts.infinitive = root + (root.match(/s$/)? 'se' : 'esse');
        }
        break;
      case 'ferre':
        if(verbEnding[5][0] == 'f') {
          root = orth.slice(0,-verbEnding[5].length);
          parts.infinitive = root + 'ferre';
        }
        break;
      default:
        console.warn('Unrecognized verb conjugation: ' + conj);
        break;
    }
  });
  return parts;
}
$(function($){
  var _verbs;
  $('#regex').val(localStorage.verbRegex||'');
  $.getJSON('output/verbs.json',function(verbs){
    _verbs = verbs;
    $('#verb-count').text(verbs.length);
    var $tbody = $('tbody');
    var i=0;
    var verbRegex = / v\. (?:[n|a]|inch|dep|impers|act|neutral)[\.,\s]/;
    verbs.forEach(function(verb){
      var parts = getVerbParts(verb.orthography, verb.verbMatch);
      var tr = $('<tr/>');
      tr.append($('<td/>').text(verb.orthography));
      tr.append($('<td/>').text(verb.verbMatch[1] && verb.verbMatch[1].join(', ') || ''));
      tr.append($('<td/>').text(parts.infinitive || 'undetermined'));
      var match = verbRegex.exec(verb.fullText);
      if(!match) {
        console.info(verb.fullText);
        tr.show();
      }
      else {
        verb.verbParts = verb.fullText.slice(0,match.index+match[0].length);
        //tr.append($('<td/>').html(verb.verbParts.replace(verb.verbType,'<b>'+verb.verbType+'</b>')));
      }
      $tbody.append(tr);
    });
    $rows = $('tbody>tr');
    //$('#regex').keyup();
  });
  var $rows = $('tbody>tr');
  $('#regex').on('keyup', function(){
    var curVal = localStorage.verbRegex = $(this).val();
    var regex;
    try {
      regex = new RegExp(curVal,'ig');
    } catch(e) {
      $('#valid').hide();
      $('#invalid').text(e.toString()).show();
      console.info(e);
      return;
    }
    $('#valid').show(); $('#invalid').hide();
    
    $('#matches').text(_verbs.reduce(function(count, verb, index){
      regex.exec('');
      var match = regex.exec(verb.orthography);
      var $row = $($rows.get(index)).toggle(!match);
      
      return count + (match? 1 : 0);
    },0));
  });
});
</script>
</body>
</html>